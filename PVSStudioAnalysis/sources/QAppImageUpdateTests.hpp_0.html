
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>QAppImageUpdateTests.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef QAPPIMAGE_UPDATE_TESTS_HPP_INCLUDED</a>
<a name="ln2">#define QAPPIMAGE_UPDATE_TESTS_HPP_INCLUDED</a>
<a name="ln3">#include &lt;QTest&gt;</a>
<a name="ln4">#include &lt;QSignalSpy&gt;</a>
<a name="ln5">#include &lt;QTemporaryDir&gt;</a>
<a name="ln6">#include &lt;QAppImageUpdate&gt;</a>
<a name="ln7">#include &lt;QScopedPointer&gt;</a>
<a name="ln8">#include &lt;QDebug&gt;</a>
<a name="ln9">#include &lt;QStringList&gt;</a>
<a name="ln10">#include &lt;QCoreApplication&gt;</a>
<a name="ln11">#include &lt;QJsonObject&gt;</a>
<a name="ln12">#include &lt;QtConcurrent&gt;</a>
<a name="ln13">#include &lt;QFuture&gt;</a>
<a name="ln14">#include &lt;QEventLoop&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;SimpleDownload.hpp&quot;</a>
<a name="ln17"> </a>
<a name="ln18">class QAppImageUpdateTests : public QObject {</a>
<a name="ln19">    Q_OBJECT</a>
<a name="ln20">    QScopedPointer&lt;QTemporaryDir&gt; m_TempDir;</a>
<a name="ln21">    QStringList m_Available;</a>
<a name="ln22">  private slots:</a>
<a name="ln23">    void initTestCase(void) {</a>
<a name="ln24">        SimpleDownload downloader;</a>
<a name="ln25"> </a>
<a name="ln26">        m_TempDir.reset(new QTemporaryDir);</a>
<a name="ln27">        if(!m_TempDir-&gt;isValid()) {</a>
<a name="ln28">            QFAIL(&quot;Cannot create temporary directory&quot;);</a>
<a name="ln29">            emit finished();</a>
<a name="ln30">            return;</a>
<a name="ln31">        }</a>
<a name="ln32"> </a>
<a name="ln33">        /// The testable AppImages</a>
<a name="ln34">        QStringList urls;</a>
<a name="ln35"> </a>
<a name="ln36">        /// Github based AppImage Update</a>
<a name="ln37">        urls /* Small AppImages */</a>
<a name="ln38">                &lt;&lt; &quot;https://github.com/AppImage/AppImageKit/releases/download/10/appimagetool-x86_64.AppImage&quot;</a>
<a name="ln39">#ifdef QUICK_TEST</a>
<a name="ln40">                ;</a>
<a name="ln41">#else</a>
<a name="ln42">                /* Slightly larger AppImage */</a>
<a name="ln43">                &lt;&lt; &quot;https://github.com/antony-jr/AppImageUpdater/releases/download/14/AppImageUpdater-9b4000e-x86_64.AppImage&quot;</a>
<a name="ln44">                /* Largest AppImage */</a>
<a name="ln45">                /* Temporarily Disable FreeCAD update check because it has broken release right now</a>
<a name="ln46">		   as of 19/02/2021.</a>
<a name="ln47">		&lt;&lt; &quot;https://github.com/FreeCAD/FreeCAD/releases/download/0.18.2/FreeCAD_0.18-16117-Linux-Conda_Py3Qt5_glibc2.12-x86_64.AppImage&quot;*/</a>
<a name="ln48">                ;</a>
<a name="ln49"> </a>
<a name="ln50">        /// Bintray based AppImage Update</a>
<a name="ln51">        urls /* Large AppImage &lt; 200 MiB */</a>
<a name="ln52">                &lt;&lt; &quot;https://bintray.com/probono/AppImages/download_file?file_path=Blender-2.78-x86_64.AppImage&quot;</a>
<a name="ln53">                &lt;&lt; &quot;https://bintray.com/probono/AppImages/download_file?file_path=FreeCAD-0.17.git201709021132.glibc2.17-x86_64.AppImage&quot;;</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">        /// Direct zsync AppImage Update</a>
<a name="ln57">        urls &lt;&lt; &quot;https://releases.openclonk.org/snapshots/2020-08-08T17:14:06Z-master-dc43c2b72/OpenClonk-x86_64.AppImage&quot;;</a>
<a name="ln58"> </a>
<a name="ln59">        /// Gitlab zsync AppImage Update</a>
<a name="ln60">        urls &lt;&lt; &quot;https://gitlab.com/probono/QtQuickApp/-/jobs/73879740/artifacts/raw/QtQuickApp-x86_64.AppImage&quot;;</a>
<a name="ln61"> </a>
<a name="ln62">        /// Torrent Based Update supported AppImage.</a>
<a name="ln63">        urls &lt;&lt; &quot;https://github.com/antony-jr/ShareMyHost/releases/download/1/ShareMyHost-a3b2973-x86_64.AppImage&quot;;</a>
<a name="ln64"> </a>
<a name="ln65">        /// AppImage Update without range request support</a>
<a name="ln66">        /// Cannot find anything for now. Please add one if you find it.</a>
<a name="ln67">#endif // QUICK TEST</a>
<a name="ln68"> </a>
<a name="ln69">        /// Download the required testing AppImages</a>
<a name="ln70">        int count = 1;</a>
<a name="ln71">        for(auto iter = urls.begin(),</a>
<a name="ln72">                end = urls.end();</a>
<a name="ln73">                iter != end;</a>
<a name="ln74">                ++iter) {</a>
<a name="ln75">            QString path = m_TempDir-&gt;path() + &quot;/&quot; + QString::number(count) + &quot;.AppImage&quot;;</a>
<a name="ln76"> </a>
<a name="ln77">            if(!downloader.download(*iter, path)) {</a>
<a name="ln78">                m_Available &lt;&lt; path;</a>
<a name="ln79">            } else {</a>
<a name="ln80">                QWARN(&quot;Download Failed&quot;);</a>
<a name="ln81">            }</a>
<a name="ln82"> </a>
<a name="ln83">            ++count;</a>
<a name="ln84">        }</a>
<a name="ln85"> </a>
<a name="ln86">        if(m_Available.size() == 0) {</a>
<a name="ln87">            QFAIL(&quot;No AppImages to test&quot;);</a>
<a name="ln88">        }</a>
<a name="ln89">        return;</a>
<a name="ln90">    }</a>
<a name="ln91"> </a>
<a name="ln92">    void actionGetEmbeddedInfo() {</a>
<a name="ln93">        QAppImageUpdate updater;</a>
<a name="ln94">        updater.setAppImage(m_Available.at(0));</a>
<a name="ln95">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln96">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln97"> </a>
<a name="ln98">        updater.start(QAppImageUpdate::Action::GetEmbeddedInfo);</a>
<a name="ln99"> </a>
<a name="ln100">        spyInfo.wait(10 * 1000);</a>
<a name="ln101"> </a>
<a name="ln102">        QVERIFY(spyInfo.count() == 1);</a>
<a name="ln103"> </a>
<a name="ln104">        /* Get resultant QJsonObject and Compare. */</a>
<a name="ln105">        auto sg = spyInfo.takeFirst();</a>
<a name="ln106"> </a>
<a name="ln107">        QJsonObject result = sg.at(0).toJsonObject();</a>
<a name="ln108">        short action = sg.at(1).toInt();</a>
<a name="ln109"> </a>
<a name="ln110">        QVERIFY(action == QAppImageUpdate::Action::GetEmbeddedInfo);</a>
<a name="ln111"> </a>
<a name="ln112">        /* Check if the result has a json sub-object called 'FileInformation'.</a>
<a name="ln113">         * If so then compare it with our test case file information.</a>
<a name="ln114">         */</a>
<a name="ln115">        auto fileInfo = result[&quot;FileInformation&quot;].toObject();</a>
<a name="ln116"> </a>
<a name="ln117">        /* If the file info is empty then fail. */</a>
<a name="ln118">        QVERIFY(!fileInfo.isEmpty());</a>
<a name="ln119"> </a>
<a name="ln120">        auto updateInfo = result[&quot;UpdateInformation&quot;].toObject();</a>
<a name="ln121"> </a>
<a name="ln122">        /* if the update info is empty then fail. */</a>
<a name="ln123">        QVERIFY(!updateInfo.isEmpty());</a>
<a name="ln124"> </a>
<a name="ln125">        /* both are not empty , Check the value for isEmpty in the resultant. */</a>
<a name="ln126">        QVERIFY(!result[&quot;isEmpty&quot;].toBool());</a>
<a name="ln127">        return;</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">    void actionGetEmbeddedInfoAll(void) {</a>
<a name="ln131">        short action = 0;</a>
<a name="ln132">        QJsonObject result,fileInfo,updateInfo;</a>
<a name="ln133">        QList&lt;QVariant&gt; sg;</a>
<a name="ln134">        QAppImageUpdate updater;</a>
<a name="ln135">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln136">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln137"> </a>
<a name="ln138">        for(auto iter = m_Available.begin(),</a>
<a name="ln139">                end = m_Available.end();</a>
<a name="ln140">                iter != end;</a>
<a name="ln141">                ++iter) {</a>
<a name="ln142">            updater.setAppImage(*iter);</a>
<a name="ln143">            qInfo().noquote() &lt;&lt; &quot;GetEmbeddedInfo(&quot; &lt;&lt; *iter &lt;&lt; &quot;)&quot;;</a>
<a name="ln144"> </a>
<a name="ln145">            updater.start(QAppImageUpdate::Action::GetEmbeddedInfo);</a>
<a name="ln146"> </a>
<a name="ln147">            spyInfo.wait(10 * 1000);</a>
<a name="ln148">            QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln149"> </a>
<a name="ln150">            /* Get resultant QJsonObject and Compare. */</a>
<a name="ln151">            sg = spyInfo.takeFirst();</a>
<a name="ln152">            result = sg.at(0).toJsonObject();</a>
<a name="ln153">            action = sg.at(1).toInt();</a>
<a name="ln154"> </a>
<a name="ln155">            QVERIFY(action == QAppImageUpdate::Action::GetEmbeddedInfo);</a>
<a name="ln156"> </a>
<a name="ln157">            /* Check if the result has a json sub-object called 'FileInformation'.</a>
<a name="ln158">             * If so then compare it with our test case file information.</a>
<a name="ln159">             */</a>
<a name="ln160">            fileInfo = result[&quot;FileInformation&quot;].toObject();</a>
<a name="ln161"> </a>
<a name="ln162">            /* If the file info is empty then fail. */</a>
<a name="ln163">            QVERIFY(!fileInfo.isEmpty());</a>
<a name="ln164"> </a>
<a name="ln165">            updateInfo = result[&quot;UpdateInformation&quot;].toObject();</a>
<a name="ln166"> </a>
<a name="ln167">            /* if the update info is empty then fail. */</a>
<a name="ln168">            QVERIFY(!updateInfo.isEmpty());</a>
<a name="ln169"> </a>
<a name="ln170">            /* both are not empty , Check the value for isEmpty in the resultant. */</a>
<a name="ln171">            QVERIFY(!result[&quot;isEmpty&quot;].toBool());</a>
<a name="ln172">        }</a>
<a name="ln173">    }</a>
<a name="ln174"> </a>
<a name="ln175">    void actionCheckForUpdate() {</a>
<a name="ln176">        QAppImageUpdate updater;</a>
<a name="ln177">        updater.setAppImage(m_Available.at(0));</a>
<a name="ln178">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln179"> </a>
<a name="ln180">        QEventLoop loop;</a>
<a name="ln181">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln182">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln183"> </a>
<a name="ln184">        updater.start(QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln185">        loop.exec();</a>
<a name="ln186"> </a>
<a name="ln187">        QVERIFY(spyInfo.count() == 1);</a>
<a name="ln188"> </a>
<a name="ln189">        auto sg = spyInfo.takeFirst();</a>
<a name="ln190">        QJsonObject result = sg.at(0).toJsonObject();</a>
<a name="ln191">        short action = sg.at(1).toInt();</a>
<a name="ln192"> </a>
<a name="ln193">        QVERIFY(action == QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln194">        QVERIFY(result.contains(&quot;UpdateAvailable&quot;));</a>
<a name="ln195">    }</a>
<a name="ln196"> </a>
<a name="ln197">    void actionCheckForUpdateAll() {</a>
<a name="ln198">        short action = 0;</a>
<a name="ln199">        QJsonObject result;</a>
<a name="ln200">        QList&lt;QVariant&gt; sg;</a>
<a name="ln201">        QAppImageUpdate updater;</a>
<a name="ln202">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln203">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln204">        QEventLoop loop;</a>
<a name="ln205">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln206"> </a>
<a name="ln207">        for(auto iter = m_Available.begin(),</a>
<a name="ln208">                end = m_Available.end();</a>
<a name="ln209">                iter != end;</a>
<a name="ln210">                ++iter) {</a>
<a name="ln211">            updater.setAppImage(*iter);</a>
<a name="ln212">            qInfo().noquote() &lt;&lt; &quot;CheckForUpdate(&quot; &lt;&lt; *iter &lt;&lt; &quot;)&quot;;</a>
<a name="ln213"> </a>
<a name="ln214">            updater.start(QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln215">            loop.exec();</a>
<a name="ln216"> </a>
<a name="ln217">            QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln218"> </a>
<a name="ln219">            sg = spyInfo.takeFirst();</a>
<a name="ln220">            result = sg.at(0).toJsonObject();</a>
<a name="ln221">            action = sg.at(1).toInt();</a>
<a name="ln222"> </a>
<a name="ln223">            QVERIFY(action == QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln224">            QVERIFY(result.contains(&quot;UpdateAvailable&quot;));</a>
<a name="ln225">        }</a>
<a name="ln226">    }</a>
<a name="ln227"> </a>
<a name="ln228">    void actionUpdate() {</a>
<a name="ln229">        short action = 0;</a>
<a name="ln230">        QJsonObject result;</a>
<a name="ln231">        QList&lt;QVariant&gt; sg;</a>
<a name="ln232">        QAppImageUpdate updater;</a>
<a name="ln233">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln234">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln235">        QEventLoop loop;</a>
<a name="ln236">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln237"> </a>
<a name="ln238">        updater.setAppImage(m_Available.at(0));</a>
<a name="ln239">        updater.start(QAppImageUpdate::Action::Update);</a>
<a name="ln240"> </a>
<a name="ln241">        loop.exec();</a>
<a name="ln242"> </a>
<a name="ln243">        QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln244"> </a>
<a name="ln245">        sg = spyInfo.takeFirst();</a>
<a name="ln246">        result = sg.at(0).toJsonObject();</a>
<a name="ln247">        action = sg.at(1).toInt();</a>
<a name="ln248"> </a>
<a name="ln249">        QVERIFY(action == QAppImageUpdate::Action::Update);</a>
<a name="ln250">        QVERIFY(result.contains(&quot;NewVersionSha1Hash&quot;));</a>
<a name="ln251"> </a>
<a name="ln252">        /// Remove the appimage if its updated.</a>
<a name="ln253">        QFile::remove(result[&quot;NewVersionPath&quot;].toString());</a>
<a name="ln254">    }</a>
<a name="ln255"> </a>
<a name="ln256">    // Test the default action sequence</a>
<a name="ln257">    // CheckForUpdate -&gt; Update</a>
<a name="ln258">    // Make sure that exactly the required signals are</a>
<a name="ln259">    // emitted.</a>
<a name="ln260">    void actionSequenceAll() {</a>
<a name="ln261">        short action = 0;</a>
<a name="ln262">        QJsonObject result;</a>
<a name="ln263">        QList&lt;QVariant&gt; sg;</a>
<a name="ln264">        QAppImageUpdate updater;</a>
<a name="ln265">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln266">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln267">        QEventLoop loop;</a>
<a name="ln268">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln269"> </a>
<a name="ln270">        for(auto iter = m_Available.begin(),</a>
<a name="ln271">                end = m_Available.end();</a>
<a name="ln272">                iter != end;</a>
<a name="ln273">                ++iter) {</a>
<a name="ln274">            updater.setAppImage(*iter);</a>
<a name="ln275">            qInfo().noquote() &lt;&lt; &quot;Update(&quot; &lt;&lt; *iter &lt;&lt; &quot;)&quot;;</a>
<a name="ln276"> </a>
<a name="ln277">            updater.start(QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln278">            loop.exec();</a>
<a name="ln279"> </a>
<a name="ln280">            QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln281"> </a>
<a name="ln282">            sg = spyInfo.takeFirst();</a>
<a name="ln283">            result = sg.at(0).toJsonObject();</a>
<a name="ln284">            action = sg.at(1).toInt();</a>
<a name="ln285"> </a>
<a name="ln286">            QVERIFY(action == QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln287">            QVERIFY(result.contains(&quot;UpdateAvailable&quot;));</a>
<a name="ln288"> </a>
<a name="ln289">            bool torrentSupported = result[&quot;TorrentSupported&quot;].toBool();</a>
<a name="ln290">            auto remoteSha1 = result[&quot;RemoteSha1Hash&quot;].toString();</a>
<a name="ln291"> </a>
<a name="ln292">            // Now Update</a>
<a name="ln293">            updater.start();</a>
<a name="ln294">            loop.exec();</a>
<a name="ln295"> </a>
<a name="ln296">            QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln297"> </a>
<a name="ln298">            sg = spyInfo.takeFirst();</a>
<a name="ln299">            result = sg.at(0).toJsonObject();</a>
<a name="ln300">            action = sg.at(1).toInt();</a>
<a name="ln301"> </a>
<a name="ln302">            QVERIFY(action == QAppImageUpdate::Action::Update);</a>
<a name="ln303">            QCOMPARE(remoteSha1, result[&quot;NewVersionSha1Hash&quot;].toString());</a>
<a name="ln304"> </a>
<a name="ln305">            /// Should not use torrent if it supports it.</a>
<a name="ln306">            if(torrentSupported ) {</a>
<a name="ln307">                QCOMPARE(false, result[&quot;UsedTorrent&quot;].toBool());</a>
<a name="ln308">            }</a>
<a name="ln309"> </a>
<a name="ln310">            /// Remove all appimage if its updated.</a>
<a name="ln311">            QFile::remove(result[&quot;NewVersionPath&quot;].toString());</a>
<a name="ln312">        }</a>
<a name="ln313">    }</a>
<a name="ln314"> </a>
<a name="ln315">    // Same asa actionSequenceAll but with non single </a>
<a name="ln316">    // threaded mode.</a>
<a name="ln317">    void actionSequenceAllNonSingleThreaded() {</a>
<a name="ln318">        short action = 0;</a>
<a name="ln319">        QJsonObject result;</a>
<a name="ln320">        QList&lt;QVariant&gt; sg;</a>
<a name="ln321">        QAppImageUpdate updater(/*singleThreaded=*/false);</a>
<a name="ln322">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln323">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln324">        QEventLoop loop;</a>
<a name="ln325">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln326"> </a>
<a name="ln327">        for(auto iter = m_Available.begin(),</a>
<a name="ln328">                end = m_Available.end();</a>
<a name="ln329">                iter != end;</a>
<a name="ln330">                ++iter) {</a>
<a name="ln331">            updater.setAppImage(*iter);</a>
<a name="ln332">            qInfo().noquote() &lt;&lt; &quot;Update(&quot; &lt;&lt; *iter &lt;&lt; &quot;)&quot;;</a>
<a name="ln333"> </a>
<a name="ln334">            updater.start(QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln335">            loop.exec();</a>
<a name="ln336"> </a>
<a name="ln337">            QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln338"> </a>
<a name="ln339">            sg = spyInfo.takeFirst();</a>
<a name="ln340">            result = sg.at(0).toJsonObject();</a>
<a name="ln341">            action = sg.at(1).toInt();</a>
<a name="ln342"> </a>
<a name="ln343">            QVERIFY(action == QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln344">            QVERIFY(result.contains(&quot;UpdateAvailable&quot;));</a>
<a name="ln345"> </a>
<a name="ln346">            bool torrentSupported = result[&quot;TorrentSupported&quot;].toBool();</a>
<a name="ln347">            auto remoteSha1 = result[&quot;RemoteSha1Hash&quot;].toString();</a>
<a name="ln348"> </a>
<a name="ln349">            // Now Update</a>
<a name="ln350">            updater.start();</a>
<a name="ln351">            loop.exec();</a>
<a name="ln352"> </a>
<a name="ln353">            QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln354"> </a>
<a name="ln355">            sg = spyInfo.takeFirst();</a>
<a name="ln356">            result = sg.at(0).toJsonObject();</a>
<a name="ln357">            action = sg.at(1).toInt();</a>
<a name="ln358"> </a>
<a name="ln359">            QVERIFY(action == QAppImageUpdate::Action::Update);</a>
<a name="ln360">            QCOMPARE(remoteSha1, result[&quot;NewVersionSha1Hash&quot;].toString());</a>
<a name="ln361"> </a>
<a name="ln362">            /// Should not use torrent if it supports it.</a>
<a name="ln363">            if(torrentSupported ) {</a>
<a name="ln364">                QCOMPARE(false, result[&quot;UsedTorrent&quot;].toBool());</a>
<a name="ln365">            }</a>
<a name="ln366"> </a>
<a name="ln367">            /// Remove all appimage if its updated.</a>
<a name="ln368">            QFile::remove(result[&quot;NewVersionPath&quot;].toString());</a>
<a name="ln369">        }</a>
<a name="ln370">    }</a>
<a name="ln371"> </a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">    void actionCancelGetEmbeddedInfo() {</a>
<a name="ln375">        QAppImageUpdate updater;</a>
<a name="ln376">        updater.setAppImage(m_Available.at(0));</a>
<a name="ln377">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln378">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln379">        QSignalSpy cancelInfo(&amp;updater, SIGNAL(canceled(short)));</a>
<a name="ln380"> </a>
<a name="ln381">        updater.start(QAppImageUpdate::Action::GetEmbeddedInfo);</a>
<a name="ln382">        updater.cancel();</a>
<a name="ln383"> </a>
<a name="ln384">        cancelInfo.wait(10 * 1000);</a>
<a name="ln385"> </a>
<a name="ln386">        /// We should only have the cancel signal emitted.</a>
<a name="ln387">        QCOMPARE(spyInfo.count(), 0);</a>
<a name="ln388">        QCOMPARE(cancelInfo.count(), 1);</a>
<a name="ln389"> </a>
<a name="ln390">        /* Get resultant QJsonObject and Compare. */</a>
<a name="ln391">        auto sg = cancelInfo.takeFirst();</a>
<a name="ln392"> </a>
<a name="ln393">        short action = sg.at(0).toInt();</a>
<a name="ln394"> </a>
<a name="ln395">        QVERIFY(action == QAppImageUpdate::Action::GetEmbeddedInfo);</a>
<a name="ln396">        return;</a>
<a name="ln397"> </a>
<a name="ln398">    }</a>
<a name="ln399"> </a>
<a name="ln400">    void actionCancelCheckForUpdate() {</a>
<a name="ln401">        QAppImageUpdate updater;</a>
<a name="ln402">        updater.setAppImage(m_Available.at(0));</a>
<a name="ln403">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln404"> </a>
<a name="ln405">        QEventLoop loop;</a>
<a name="ln406">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln407">        QSignalSpy cancelInfo(&amp;updater, SIGNAL(canceled(short)));</a>
<a name="ln408">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln409">        connect(&amp;updater, &amp;QAppImageUpdate::canceled, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln410"> </a>
<a name="ln411">        updater.start(QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln412">        updater.cancel();</a>
<a name="ln413"> </a>
<a name="ln414">        loop.exec();</a>
<a name="ln415"> </a>
<a name="ln416">        /// We should only have the cancel signal emitted.</a>
<a name="ln417">        QCOMPARE(spyInfo.count(), 0);</a>
<a name="ln418">        QCOMPARE(cancelInfo.count(), 1);</a>
<a name="ln419"> </a>
<a name="ln420">        auto sg = cancelInfo.takeFirst();</a>
<a name="ln421">        short action = sg.at(0).toInt();</a>
<a name="ln422"> </a>
<a name="ln423">        QVERIFY(action == QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    void actionCancelUpdate() {</a>
<a name="ln427">        short action = 0;</a>
<a name="ln428">        QJsonObject result;</a>
<a name="ln429">        QList&lt;QVariant&gt; sg;</a>
<a name="ln430">        QAppImageUpdate updater;</a>
<a name="ln431">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln432">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln433">        QSignalSpy cancelInfo(&amp;updater, SIGNAL(canceled(short)));</a>
<a name="ln434"> </a>
<a name="ln435">        QEventLoop loop;</a>
<a name="ln436">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln437">        connect(&amp;updater, &amp;QAppImageUpdate::canceled, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln438"> </a>
<a name="ln439">        updater.setAppImage(m_Available.at(0));</a>
<a name="ln440"> </a>
<a name="ln441">        /// Cancel as soon as the delta writer starts up</a>
<a name="ln442">        connect(&amp;updater, &amp;QAppImageUpdate::started, &amp;updater, &amp;QAppImageUpdate::cancel, Qt::DirectConnection);</a>
<a name="ln443"> </a>
<a name="ln444">        /// Start the updater.</a>
<a name="ln445">        updater.start();</a>
<a name="ln446"> </a>
<a name="ln447">        loop.exec();</a>
<a name="ln448"> </a>
<a name="ln449">        /// We should only have the cancel signal emitted.</a>
<a name="ln450">        QCOMPARE(spyInfo.count(), 0);</a>
<a name="ln451">        QCOMPARE(cancelInfo.count(), 1);</a>
<a name="ln452"> </a>
<a name="ln453">        sg = cancelInfo.takeFirst();</a>
<a name="ln454">        action = sg.at(0).toInt();</a>
<a name="ln455"> </a>
<a name="ln456">        QVERIFY(action == QAppImageUpdate::Action::Update);</a>
<a name="ln457">    }</a>
<a name="ln458"> </a>
<a name="ln459">#ifdef DECENTRALIZED_UPDATE_ENABLED</a>
<a name="ln460">    void actionUpdateWithTorrent() {</a>
<a name="ln461">        short action = 0;</a>
<a name="ln462">        QJsonObject result;</a>
<a name="ln463">        QList&lt;QVariant&gt; sg;</a>
<a name="ln464">        QAppImageUpdate updater;</a>
<a name="ln465">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln466">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln467">        QEventLoop loop;</a>
<a name="ln468">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">        //// Search for all test files which supports torrent update and</a>
<a name="ln472">        //// Update it with torrents.</a>
<a name="ln473">        for(auto iter = m_Available.begin(),</a>
<a name="ln474">                end = m_Available.end();</a>
<a name="ln475">                iter != end;</a>
<a name="ln476">                ++iter) {</a>
<a name="ln477">            updater.setAppImage(*iter);</a>
<a name="ln478">            qInfo().noquote() &lt;&lt; &quot;Update(&quot; &lt;&lt; *iter &lt;&lt; &quot;)&quot;;</a>
<a name="ln479"> </a>
<a name="ln480">            updater.start(QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln481">            loop.exec();</a>
<a name="ln482"> </a>
<a name="ln483">            QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln484"> </a>
<a name="ln485">            sg = spyInfo.takeFirst();</a>
<a name="ln486">            result = sg.at(0).toJsonObject();</a>
<a name="ln487">            action = sg.at(1).toInt();</a>
<a name="ln488"> </a>
<a name="ln489">            QVERIFY(action == QAppImageUpdate::Action::CheckForUpdate);</a>
<a name="ln490">            QVERIFY(result.contains(&quot;UpdateAvailable&quot;));</a>
<a name="ln491"> </a>
<a name="ln492">            auto remoteSha1 = result[&quot;RemoteSha1Hash&quot;].toString();</a>
<a name="ln493"> </a>
<a name="ln494">            if(result[&quot;TorrentSupported&quot;].toBool())  {</a>
<a name="ln495">                // Now Update With Torrent confirmation.</a>
<a name="ln496">                updater.start(QAppImageUpdate::Action::UpdateWithTorrent);</a>
<a name="ln497">                loop.exec();</a>
<a name="ln498"> </a>
<a name="ln499">                QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln500"> </a>
<a name="ln501">                sg = spyInfo.takeFirst();</a>
<a name="ln502">                result = sg.at(0).toJsonObject();</a>
<a name="ln503">                action = sg.at(1).toInt();</a>
<a name="ln504"> </a>
<a name="ln505">                QVERIFY(action == QAppImageUpdate::Action::UpdateWithTorrent);</a>
<a name="ln506">                QCOMPARE(remoteSha1, result[&quot;NewVersionSha1Hash&quot;].toString());</a>
<a name="ln507">                QCOMPARE(true, result[&quot;UsedTorrent&quot;].toBool());</a>
<a name="ln508"> </a>
<a name="ln509">                QFile::remove(result[&quot;NewVersionPath&quot;].toString());</a>
<a name="ln510">            }</a>
<a name="ln511">        }</a>
<a name="ln512">    }</a>
<a name="ln513">#endif // DECENTRALIZED_UPDATE_ENABLED</a>
<a name="ln514"> </a>
<a name="ln515">    //// This should not crash the test</a>
<a name="ln516">    //// That is the test.</a>
<a name="ln517">    void destructWhileUpdate() {</a>
<a name="ln518">        {</a>
<a name="ln519">            QAppImageUpdate updater;</a>
<a name="ln520">            QEventLoop startLoop;</a>
<a name="ln521">            connect(&amp;updater, &amp;QAppImageUpdate::started, &amp;startLoop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln522">            connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln523"> </a>
<a name="ln524">            updater.setAppImage(m_Available.at(0));</a>
<a name="ln525">            updater.start();</a>
<a name="ln526"> </a>
<a name="ln527">            // Destruct as soon as the update starts.</a>
<a name="ln528">            startLoop.exec();</a>
<a name="ln529">        }</a>
<a name="ln530">    }</a>
<a name="ln531"> </a>
<a name="ln532">    /// I have no idea on how to test thread safety,</a>
<a name="ln533">    //  so we are just gonna call setAppImage and</a>
<a name="ln534">    //  start from multiple threads.</a>
<a name="ln535">    //</a>
<a name="ln536">    //  The expected result is,</a>
<a name="ln537">    //</a>
<a name="ln538">    //  The first thread to call setAppImage and start</a>
<a name="ln539">    //  will succeed and all other threads calls will be</a>
<a name="ln540">    //  invalid and will not affect the object or segfaults.</a>
<a name="ln541">    //</a>
<a name="ln542">    //  So the QSignalSpy should have only one signal that</a>
<a name="ln543">    //  is finished. and not multiple signals.</a>
<a name="ln544">    void threadSafety() {</a>
<a name="ln545">        QAppImageUpdate updater;</a>
<a name="ln546">        QEventLoop loop;</a>
<a name="ln547">        connect(&amp;updater, &amp;QAppImageUpdate::error, this, &amp;QAppImageUpdateTests::defaultErrorHandler);</a>
<a name="ln548">        QSignalSpy spyInfo(&amp;updater, SIGNAL(finished(QJsonObject, short)));</a>
<a name="ln549">        connect(&amp;updater, &amp;QAppImageUpdate::finished, &amp;loop, &amp;QEventLoop::quit, Qt::QueuedConnection);</a>
<a name="ln550"> </a>
<a name="ln551">        auto function = [&amp;]() {</a>
<a name="ln552">            updater.setAppImage(m_Available.at(0));</a>
<a name="ln553">            updater.start();</a>
<a name="ln554">        };</a>
<a name="ln555"> </a>
<a name="ln556">        auto future1 = new QFuture&lt;void&gt;;</a>
<a name="ln557">        auto future2 = new QFuture&lt;void&gt;;</a>
<a name="ln558">        auto future3 = new QFuture&lt;void&gt;;</a>
<a name="ln559">        auto future4 = new QFuture&lt;void&gt;;</a>
<a name="ln560">        *future1 = QtConcurrent::run(function);</a>
<a name="ln561">        *future2 = QtConcurrent::run(function);</a>
<a name="ln562">        *future3 = QtConcurrent::run(function);</a>
<a name="ln563">        *future4 = QtConcurrent::run(function);</a>
<a name="ln564"> </a>
<a name="ln565">        /// Wait for all futures to end;</a>
<a name="ln566">        while(future1-&gt;isRunning() || future2-&gt;isRunning() ||</a>
<a name="ln567">                future3-&gt;isRunning() || future4-&gt;isRunning()) {</a>
<a name="ln568">            QCoreApplication::processEvents();</a>
<a name="ln569">        }</a>
<a name="ln570"> </a>
<a name="ln571">        delete future1;</a>
<a name="ln572">        delete future2;</a>
<a name="ln573">        delete future3;</a>
<a name="ln574">        delete future4;</a>
<a name="ln575"> </a>
<a name="ln576">        if(spyInfo.count() &lt; 1) {</a>
<a name="ln577">            if(!spyInfo.wait()) {</a>
<a name="ln578">                loop.exec();</a>
<a name="ln579">            }</a>
<a name="ln580">        }</a>
<a name="ln581"> </a>
<a name="ln582">        QCOMPARE(spyInfo.count(), 1);</a>
<a name="ln583"> </a>
<a name="ln584">        auto sg = spyInfo.takeFirst();</a>
<a name="ln585">        QJsonObject result = sg.at(0).toJsonObject();</a>
<a name="ln586">        short action = sg.at(1).toInt();</a>
<a name="ln587"> </a>
<a name="ln588">        QVERIFY(action == QAppImageUpdate::Action::Update);</a>
<a name="ln589">    }</a>
<a name="ln590"> </a>
<a name="ln591">    void cleanupTestCase(void) {</a>
<a name="ln592">        m_TempDir-&gt;remove();</a>
<a name="ln593">        emit finished();</a>
<a name="ln594">        return;</a>
<a name="ln595">    }</a>
<a name="ln596">  protected slots:</a>
<a name="ln597">    void defaultErrorHandler(short code, short action) {</a>
<a name="ln598">        Q_UNUSED(action);</a>
<a name="ln599">        auto scode = QAppImageUpdate::errorCodeToString(code);</a>
<a name="ln600">        scode.prepend(&quot;error:: &quot;);</a>
<a name="ln601">        QFAIL(QTest::toString(scode));</a>
<a name="ln602">        return;</a>
<a name="ln603">    }</a>
<a name="ln604">  Q_SIGNALS:</a>
<a name="ln605">    void finished(void);</a>
<a name="ln606">};</a>
<a name="ln607">#endif</a>

</code></pre>
<div class="balloon" rel="29"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
